/****************************************************************************
 *
 *                            Copyright (c), 2010
 *                            All rights reserved
 *
 *                            DIGITAL DISPATCH SYSTEMS, INC
 *                            RICHMOND, BRITISH COLUMBIA
 *                            CANADA
 *
 ****************************************************************************
 *
 *
 * $Log: /TaxiProduct/Code/ControlRoom/iTaxiInterface/src/com/dds/pathfinder/itaxiinterface/osp/impl/CancelOrderByConfNumImplement.java $
 * 
 * PF-16104, June 5th, 2014, UDI should be able to cancel any job too.
 * 
 * 7     12/20/13 2:13p Dchen
 * PF-15469, add origin code for cancelling job as well.
 * 
 * 6     12/19/13 3:32p Dchen
 * PF-15469, add origin code for cancelling job as well.
 * 
 * 5     10/25/12 11:00a Ezhang
 * PF-14809 Added confirmation number check so it won't allow cancel 
 * unless the the system id is the same as when the job was created
 * 
 * 4     2/12/11 10:00a Ezhang
 * C36130 Added system id validation
 * 
 * 3     9/24/10 5:47p Ezhang
 * bug fix.
 * 
 * 2     9/20/10 2:08p Ezhang
 * OSP 2.0 new method.
 */
package com.dds.pathfinder.itaxiinterface.osp.impl;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;

import javax.sql.DataSource;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

import com.dds.pathfinder.itaxiinterface.osp.impl.UpdateOrderByConfNumImplement.UpdateOrderByConfNumErrorCode;
import com.dds.pathfinder.itaxiinterface.webservice.BaseReq;
import com.dds.pathfinder.itaxiinterface.webservice.CancelJobListItem;
import com.dds.pathfinder.itaxiinterface.webservice.CancelOrderByConfNumReq;
import com.dds.pathfinder.itaxiinterface.webservice.CancelOrderByConfNumRes;
import com.dds.pathfinder.itaxiinterface.webservice.GenErrMsgRes;



/**
 * @author ezhang
 * @version 2.0  10 Sep 2010
 * CancelOrderByConfNumImplement performs cancellation by confirmation number(aka booking_id of Orders table)
 * It retrieves all jobs generated by the same booking event and cancel all jobs directly 
 * as long as the job is not in completed, passenger on board or on hold state.
 */
public class CancelOrderByConfNumImplement extends OSPBaseImplement {

	private Logger logger = LogManager.getLogger(this.getClass());
	
    private DataSource pfDataSource;
    private ArrayList<CancelJobListItem> jobList = new ArrayList<CancelJobListItem>();
    
    public enum CancelOrderByConfNumErrorCode {
		NO_ERROR(0),
		NOT_AUTHENTICATED(1),
		INVALID_SESSIONID(2),
		ORDER_NOT_FOUND(3),
		INVALID_CONFNUM(4),
		DEFAULT_ERROR(99);
		
		private int code;
		
		private CancelOrderByConfNumErrorCode(int c) {
			   code = c;
		}

		public int getCode() {
			   return code;
		}
	};
	
	public CancelOrderByConfNumImplement(DataSource pfDataSource) {
		super();
		this.pfDataSource = pfDataSource;
	}
	
	public CancelOrderByConfNumRes generateResponse(BaseReq request) {
		return generateCancelOrderByConfNumResponse((CancelOrderByConfNumReq)request);
		
	}
	
	private CancelOrderByConfNumRes generateCancelOrderByConfNumResponse(CancelOrderByConfNumReq request){
		CancelOrderByConfNumRes response = getDefaultResponse(request);
		if(!validateRequest(request, response)){
			   return response;
		}
		String confNumStr = request.getConfirmationNum();
		
		getCancelJobList(request, Long.parseLong(confNumStr.trim()), response);
		
		return response;
	}
	
	private CancelOrderByConfNumRes getDefaultResponse(CancelOrderByConfNumReq request){
		
		CancelOrderByConfNumRes response = new CancelOrderByConfNumRes();
		   
		response.setRequestStatus(GenErrMsgRes.STATUS_FAILED);
		response.setErrorMessage(GenErrMsgRes.ERROR_CODE_FAILED);
		response.setErrorCode(CancelOrderByConfNumErrorCode.DEFAULT_ERROR.getCode());
		   
		return response;
	}
	
	/**
	 * Validate Cancel Order by Confirmation request.
	 * 
	 * @param request
	 *            the request to validate
	 * @param response
	 *            the response to update if error
	 * @return true if valid, false otherwise
	 */
	private boolean validateRequest(CancelOrderByConfNumReq request, CancelOrderByConfNumRes response) {
		
		if (request == null || response == null) {
			return false;
		}
		//C36130 validate system id
		if(validateSystemId(pfDataSource, request) == false){
			response.setErrorMessage(GenErrMsgRes.ERROR_CODE_NOT_AUTHENTICATED);
			response.setErrorCode(CancelOrderByConfNumErrorCode.NOT_AUTHENTICATED.getCode());
			return false;
		}
		
		//validate confirmation number
		if (request.getConfirmationNum() == null || request.getConfirmationNum().trim().length() == 0){
			response.setErrorMessage(GenErrMsgRes.ERROR_CODE_INVALID_REQUEST);
			response.setErrorCode(CancelOrderByConfNumErrorCode.INVALID_CONFNUM.getCode());
			return false;
		}
		//validate request type
		if(request.getRequestType() == null ||request.getRequestType() != REQUEST_TYPE_CANCEL_JOB ){
			response.setErrorMessage(GenErrMsgRes.ERROR_CODE_INVALID_REQUEST);
			return false;
		}
		
		//PF-14809 validate the confirmation number from the same system as it was created
		if(!validateConfirmationNumber(request)){
			response.setErrorMessage(GenErrMsgRes.ERROR_CODE_INVALID_REQUEST);
			response.setErrorCode(UpdateOrderByConfNumErrorCode.INVALID_CONFNUM.getCode());
			return false;
		}
		return true;
	}
	/**
	 * get the job_id and job_status associated with the booking_id.
	 * 
	 * @param confNum
	 *            the request to get the jobs
	 * @param response
	 *            the response to update if error
	 * @return true if jobs found, false otherwise
	 */
	private void getCancelJobList(CancelOrderByConfNumReq request, Long confNum, CancelOrderByConfNumRes response) {
		Connection con = null;
		PreparedStatement stmt = null;
        ResultSet rs = null;
        CallableStatement cs = null;
        
        try{
        	con = pfDataSource.getConnection();
        	String query = " select jb.job_id, DECODE(jb.current_job_stage, 'H', DECODE(NVL(jb.locked_by_code, user), user, jb.prev_job_stage, 'H'),jb.current_job_stage)status, vs.vehicle_status" +
        					" from jobs jb, Orders od, vehicle_states vs" +
        					" where jb.order_id = od.order_id" +
        					" and vs.current_job_id (+) = jb.job_id" +
        					" and od.booking_id = " + confNum;
        	logger.info("getCancelJobList query " + query);
        	stmt = con.prepareStatement(query);
        	rs = stmt.executeQuery();
 
        	while(rs.next()){
        		String status = rs.getString("status");
        		Long job_id = rs.getLong("job_id");
        		String v_status = rs.getString("vehicle_status");
        		int tripCancelStatus = 0; // default the cancellation status as not allowed = 1; 
        		if(status.charAt(0)== JOB_STATUS_HOLD.charAt(0)){
        			tripCancelStatus = 3; // The trip is locked by another user, the cancellation is not allowed		
        		}
        		//Pathfinder actually allows cancellation when passenger is on board or trip is canceled or completed.
        		//but this is OSP requirement so I leave it here.
        		else if (status.charAt(0) == JOB_STATUS_VEHICLE.charAt(0) && v_status.charAt(0) == VEHICLES_STATUS_TAXI_POB.charAt(0) ){
        			tripCancelStatus = 1; // The trip is in service, the cancellation is not allowed
        		}
        		else if(status.charAt(0) == JOB_STATUS_COMPLETE.charAt(0) ||  status.charAt(0) == JOB_STATUS_PENDING.charAt(0)){
        			tripCancelStatus = 2; // The trip is transferred, the cancellation is not allowed
        		}
        		
        		if( tripCancelStatus != 0){
        			jobList.add(new CancelJobListItem(job_id, tripCancelStatus));
        			logger.info("no cancel job " + job_id);
        		}
        		else
        		{	
        			String userName = getUserName(request, request.getSessionID());
        			if(!canceljob(job_id, userName)){
        				tripCancelStatus = 4; //failed for whatever reason
        				jobList.add(new CancelJobListItem(job_id, tripCancelStatus));
        			}
        			else{
        				jobList.add(new CancelJobListItem(job_id, tripCancelStatus));
        			}
        			
        		}
        		
        	}
        	
        	
        }catch(SQLException se){
        	logger.error("getCancelJobList failed:", se);
        }finally{
        	if(rs != null) try{rs.close();}catch(SQLException ignore){};
        	if(stmt != null) try{stmt.close();}catch(SQLException ignore){};
        	if(con != null) try{con.close();}catch(SQLException ignore){};
        }
        generateCancelJobListResponse(response, jobList);
	}
	/**
	 * @param jobId
	 * @return true if job canceled return false if failed
	 */
	private boolean canceljob(Long jobId, String userName) {
		Connection con = null;
        CallableStatement cs = null;
        boolean status = true;
		try{
			//cancel job now
			con = pfDataSource.getConnection();
	       	cs = con.prepareCall("{ call despatch.cancel(?,?,?,?,?)}");
	       	cs.setLong(1, jobId);
	       	cs.setString(2, "Cancel Job by OSP cancel order");       	   
       	    cs.setNull(3, Types.VARCHAR);		//log_classes.log_type%TYPE DEFAULT NULL,
       	    cs.setString(4, "N");  				//p_is_redesp IN VARCHAR2 DEFAULT 'N',
       	    cs.setString(5, userName);
	       	cs.execute(); 
			
		}catch(SQLException se){
		   	logger.error("job cancellation failed with exception", se);
		   	status = false;
	       	
		}finally{
       		if(cs != null) try{cs.close();}catch(SQLException ignore){};
       		if(con != null) try{con.close();}catch(SQLException ignore){};
		}
		return status;
	}

	private void generateCancelJobListResponse(CancelOrderByConfNumRes response, ArrayList<CancelJobListItem> jobList){
		
    	int nbOfJobs = jobList.size();
    	if(nbOfJobs > 0){
    		response.setRequestStatus(GenErrMsgRes.STATUS_SUCCESS);
        	response.setErrorMessage(GenErrMsgRes.ERROR_CODE_SUCCESS);
        	response.setErrorCode(CancelOrderByConfNumErrorCode.NO_ERROR.getCode());
    		CancelJobListItem[] CancelJobList = new CancelJobListItem[nbOfJobs];
    		jobList.toArray(CancelJobList);
    		response.setCancelJobList(CancelJobList);
    	}
    	else{
    		response.setErrorCode(CancelOrderByConfNumErrorCode.ORDER_NOT_FOUND.getCode());
    	}
	}
	
	//PF-14809 validate confirmation number whether from the same system
	private boolean validateConfirmationNumber(CancelOrderByConfNumReq request) {
	
		boolean res = false;
		Connection con = null;
		Statement stmt = null;
		ResultSet result = null;
		String referenceType = null;
		int systemId = request.getSystemID();
		
		//check job_references table if request job match the reference type
		referenceType = getSystemReference(request.getSystemID());
		
		if (referenceType != null && !referenceType.isEmpty()) {
		   String query = "select jb.job_id, jr.reference_type from jobs jb, orders od, job_references jr "
				 +  " where jb.order_id = od.order_id" 
				 + " and od.booking_id = " + request.getConfirmationNum()
				 + " and jb.job_id = jr.job_id";
				
				
		
		
		   try{
			   	con = pfDataSource.getConnection();
				stmt = con.createStatement();
				result = stmt.executeQuery(query);
				//PF-14809 the job is in job_references table, if the request from match the job's reference then return true
				if (result.next() ) {
					if(result.getString("reference_type").equalsIgnoreCase(referenceType)) {
						res = true; //GFC/MB system cancel GFC/MB job PF-14809
					}
							
				}
				//PF-14809 the job is not in job_references table, if the request from webbooker then return true
				//PF-16104 UDI should be able to cancel any job too.
				else if(systemId == ExternalSystemId.SYSTEM_ID_WEB_BOOKER.getSystemId() || systemId == ExternalSystemId.SYSTEM_ID_UDI_USER.getSystemId() || isAccessableInternalJobs(systemId)) {
					res = true; //webbooker cancel webbooker job
				}
				
	       }catch(SQLException se){
		       	logger.error("validateConfirmationNumber() failed with exception", se);
		       	
	       }finally{
	    	    if (result != null)try {result.close();} catch (SQLException ignore) {};
	    	    if (stmt != null)try {stmt.close();} catch (SQLException ignore) {};
	       		if(con != null) try{con.close();}catch(SQLException ignore){};
	       		
	       }
		}
		
		
		return res;
	}

}
